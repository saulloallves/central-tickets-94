import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Re-ranking com LLM para melhorar a relev√¢ncia dos resultados
async function rerankComLLM(docs: any[], pergunta: string): Promise<any[]> {
  const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
  
  if (!openaiApiKey || docs.length === 0) {
    console.log('‚ö†Ô∏è Sem API key ou documentos para re-ranking');
    return docs;
  }

  try {
    console.log('üîÑ Iniciando re-ranking com LLM para', docs.length, 'documentos');

    // Formatar documentos para o LLM
    const documentosFormatados = docs.map((doc, index) => {
      const texto = typeof doc.conteudo === 'object' ? doc.conteudo.texto : doc.conteudo;
      return `[${index + 1}] T√≠tulo: ${doc.titulo}\nConte√∫do: ${texto?.substring(0, 500) || 'Sem conte√∫do'}`;
    }).join('\n\n');

    const prompt = `Analise os documentos existentes e determine quais s√£o SEMANTICAMENTE SIMILARES ao novo texto fornecido.

IMPORTANTE: Um documento existente √© relevante se:
- Trata do MESMO ASSUNTO/T√ìPICO principal
- Cont√©m informa√ß√µes SOBREPOSTAS ou RELACIONADAS
- Pode ser COMPLEMENTAR ou uma VERS√ÉO EXPANDIDA do novo texto
- O novo texto pode ser uma PARTE/SE√á√ÉO de um documento maior existente

Novo texto: "${pergunta}"

Documentos existentes:
${documentosFormatados}

Crit√©rios de pontua√ß√£o:
- 90-100: Mesmo assunto, muito similar ou o novo √© parte do existente
- 70-89: Assunto relacionado, informa√ß√µes complementares
- 50-69: Parcialmente relacionado
- 0-49: Pouco ou nada relacionado

Responda APENAS com um array JSON: [{"index": 1, "score": 95}, {"index": 2, "score": 80}]`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4.1-2025-04-14',
        messages: [{ role: 'user', content: prompt }],
        max_completion_tokens: 1000
      }),
    });

    if (!response.ok) {
      console.error('‚ùå Erro no re-ranking:', await response.text());
      return docs;
    }

    const data = await response.json();
    let ranking;
    
    try {
      ranking = JSON.parse(data.choices[0].message.content);
    } catch (parseError) {
      console.error('‚ùå Erro no parsing do JSON:', parseError);
      console.log('Conte√∫do recebido:', data.choices[0].message.content);
      return docs.slice(0, 5); // Fallback
    }
    
    // Aplicar re-ranking - verificar diferentes formatos de resposta
    let docsComScore = ranking;
    if (ranking.rankings) docsComScore = ranking.rankings;
    if (Array.isArray(ranking)) docsComScore = ranking;
    
    if (!Array.isArray(docsComScore)) {
      console.error('‚ùå Formato de ranking inv√°lido:', docsComScore);
      return docs.slice(0, 5);
    }
    
    const documentosReRankeados = docsComScore
      .sort((a: any, b: any) => b.score - a.score)
      .map((item: any) => ({
        ...docs[item.index - 1],
        score: item.score / 100,
        similarity: item.score / 100
      }))
      .filter((doc: any) => doc && doc.score > 0.3); // S√≥ documentos com score > 30%

    console.log('‚úÖ Re-ranking conclu√≠do:', documentosReRankeados.length, 'documentos relevantes');
    return documentosReRankeados;

  } catch (error) {
    console.error('‚ùå Erro no re-ranking:', error);
    return docs;
  }
}

// Gerar an√°lise comparativa detalhada
async function gerarAnaliseComparativa(novoConteudo: string, documentosRelacionados: any[]): Promise<string> {
  const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
  
  if (!openaiApiKey || documentosRelacionados.length === 0) {
    console.log('‚ö†Ô∏è Sem API key ou documentos para an√°lise comparativa');
    return '';
  }

  try {
    console.log('üìù Gerando an√°lise comparativa detalhada');

    const documentosFormatados = documentosRelacionados.map((doc, index) => {
      const texto = typeof doc.conteudo === 'object' ? doc.conteudo.texto : doc.conteudo;
      return `**Documento ${index + 1}: ${doc.titulo}**\n${texto?.substring(0, 800) || 'Sem conte√∫do'}`;
    }).join('\n\n');

    const prompt = `Compare o NOVO DOCUMENTO com os DOCUMENTOS EXISTENTES para identificar sobreposi√ß√µes, contradi√ß√µes e recomendar a melhor a√ß√£o.

**NOVO DOCUMENTO:**
${novoConteudo}

**DOCUMENTOS EXISTENTES:**
${documentosFormatados}

**INSTRU√á√ïES IMPORTANTES:**
- Identifique CONTRADI√á√ïES entre novo e existente
- Se o novo documento √© uma PARTE/SE√á√ÉO de um existente ‚Üí Recomende ATUALIZAR
- Se h√° CONTRADI√á√ïES/CONFLITOS ‚Üí Mencione especificamente
- Se o novo documento √© COMPLEMENTAR ‚Üí Recomende ATUALIZAR  
- Se o novo documento √© √öNICO/DIFERENTE ‚Üí Recomende CRIAR NOVO

**AN√ÅLISE:**

## üìÑ Novo Documento
**Assunto:** [tema principal]
**Tipo:** [classifica√ß√£o]

## üîç An√°lise de Sobreposi√ß√£o
**Documentos relacionados:** ${documentosRelacionados.length}
**N√≠vel de sobreposi√ß√£o:** [Alto/M√©dio/Baixo/Nenhum]

## ‚öñÔ∏è Compara√ß√£o Detalhada
**Similaridades:**
‚Ä¢ [pontos em comum]

**Diferen√ßas:**
‚Ä¢ [aspectos √∫nicos do novo]

**‚ö†Ô∏è CONTRADI√á√ïES IDENTIFICADAS:**
‚Ä¢ [liste contradi√ß√µes espec√≠ficas entre novo e existente, ou "Nenhuma contradi√ß√£o identificada"]

## üí° Recomenda√ß√£o Final
${documentosRelacionados.length > 0 ? '**SUGEST√ÉO: ATUALIZAR DOCUMENTO EXISTENTE**' : '**SUGEST√ÉO: CRIAR NOVO DOCUMENTO**'}

${documentosRelacionados.length > 0 ? 
  `**Documento para atualizar:** ${documentosRelacionados[0]?.titulo}
**Raz√£o:** [explicar o tipo de atualiza√ß√£o necess√°ria]
**A√ß√£o:** [descrever como incorporar o novo conte√∫do]` : 
  '**Justificativa:** Conte√∫do √∫nico sem sobreposi√ß√£o significativa'
}

(M√°ximo 300 palavras)`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4.1-2025-04-14',
        messages: [{ role: 'user', content: prompt }],
        max_completion_tokens: 2000
      }),
    });

    if (!response.ok) {
      console.error('‚ùå Erro na an√°lise comparativa:', await response.text());
      return '';
    }

    const data = await response.json();
    const analise = data.choices[0].message.content;

    console.log('‚úÖ An√°lise comparativa gerada:', analise.length, 'caracteres');
    return analise;

  } catch (error) {
    console.error('‚ùå Erro na an√°lise comparativa:', error);
    return '';
  }
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('üöÄ === VERIFICA√á√ÉO DE ASSUNTOS RELACIONADOS ===');
    
    const { titulo, conteudo } = await req.json();
    const textoCompleto = `T√≠tulo: ${titulo}\nConte√∫do: ${conteudo}`;
    
    console.log('üìù Dados recebidos:');
    console.log('- T√≠tulo:', titulo || 'N√£o informado');
    console.log('- Conte√∫do length:', conteudo?.length || 0);
    console.log('- Texto completo preview:', textoCompleto.substring(0, 200) + '...');

    const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
    if (!openaiApiKey) {
      throw new Error('OpenAI API key n√£o configurada');
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Credenciais do Supabase n√£o configuradas');
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    console.log('üéØ ETAPA 1: GERANDO EMBEDDING');
    console.log('- Modelo usado: text-embedding-3-small');
    console.log('- Texto completo length:', textoCompleto.length);
    console.log('- Primeiros 200 chars:', textoCompleto.substring(0, 200));

    // Truncar texto para evitar exceder limite de tokens (8192)
    // Estimativa: ~4 caracteres por token, ent√£o limitamos a ~6000 caracteres para ter margem
    const textoParaEmbedding = textoCompleto.length > 6000 
      ? textoCompleto.substring(0, 6000) + '...'
      : textoCompleto;

    console.log('- Texto truncado length:', textoParaEmbedding.length);

    // Gerar embedding usando OpenAI
    const embeddingResponse = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        input: textoParaEmbedding,
        model: 'text-embedding-3-small'
      }),
    });

    if (!embeddingResponse.ok) {
      const error = await embeddingResponse.text();
      console.error('‚ùå ERRO NO EMBEDDING:', error);
      throw new Error(`OpenAI Embeddings error: ${error}`);
    }

    const embeddingData = await embeddingResponse.json();
    const queryEmbedding = embeddingData.data[0].embedding;

    console.log('‚úÖ EMBEDDING CRIADO COM SUCESSO');
    console.log('- Dimens√µes do embedding:', queryEmbedding.length);
    console.log('- Primeiros 5 valores:', queryEmbedding.slice(0, 5));

    console.log('üéØ ETAPA 2: VERIFICANDO DOCUMENTOS NA BASE');
    
    // Primeiro verificar quantos documentos temos
    const { data: totalDocs, error: countError } = await supabase
      .from('documentos')
      .select('id, titulo, categoria')
      .eq('status', 'ativo');
      
    console.log('üìä DOCUMENTOS DISPON√çVEIS:', totalDocs?.length || 0);
    if (totalDocs) {
      totalDocs.forEach(doc => {
        console.log(`- ${doc.titulo} (${doc.categoria})`);
      });
    }

    const MAXIMO_DE_DOCUMENTOS = 12;
    
    console.log('üéØ ETAPA 3: FAZENDO BUSCA SEM√ÇNTICA');
    
    // TESTE: Primeiro vamos tentar busca simples usando match_documentos_semantico
    console.log('üîç TESTANDO BUSCA SIMPLES PRIMEIRO');
    
    const { data: candidatosSimples, error: errorSimples } = await supabase.rpc('match_documentos_semantico', {
      query_embedding: queryEmbedding,
      match_threshold: 0.1,
      match_count: MAXIMO_DE_DOCUMENTOS
    });
    
    console.log('üìã BUSCA SIMPLES - Resultado:');
    console.log('- error:', errorSimples);
    console.log('- candidatos encontrados:', candidatosSimples?.length || 0);
    
    if (candidatosSimples && candidatosSimples.length > 0) {
      console.log('‚úÖ ENCONTROU NA BUSCA SIMPLES:');
      candidatosSimples.forEach((c, i) => {
        console.log(`  ${i+1}. ${c.titulo} (similarity: ${c.similarity})`);
      });
    } else {
      console.log('‚ùå BUSCA SIMPLES N√ÉO ENCONTROU NADA');
      if (errorSimples) {
        console.error('Erro na busca simples:', errorSimples);
      }
    }

    console.log('üîç TESTANDO BUSCA H√çBRIDA');
    
    // Usa a mesma fun√ß√£o h√≠brida dos outros sistemas com par√¢metros corretos
    const { data: candidatos, error } = await supabase.rpc('match_documentos_hibrido', {
      query_embedding: queryEmbedding,
      query_text: textoCompleto,
      match_count: MAXIMO_DE_DOCUMENTOS,
      alpha: 0.85 // Peso da busca vetorial (85%) vs textual (15%)
    });

    console.log('üìã BUSCA H√çBRIDA - Resultado:');
    console.log('- error:', error);
    console.log('- candidatos encontrados:', candidatos?.length || 0);
    
    if (candidatos && candidatos.length > 0) {
      console.log('‚úÖ H√çBRIDA - Documentos encontrados:');
      candidatos.forEach((c, i) => {
        console.log(`  ${i+1}. ${c.titulo} (similarity: ${c.similarity})`);
      });
    } else {
      console.log('‚ùå BUSCA H√çBRIDA N√ÉO ENCONTROU NADA');
      if (error) {
        console.error('Erro na busca h√≠brida:', error);
      }
    }

    console.log('üéØ ETAPA 4: PROCESSANDO RESULTADOS');
    
    // Use busca simples se h√≠brida falhou, sen√£o use h√≠brida
    let artigosRelacionados = candidatos && candidatos.length > 0 ? candidatos : (candidatosSimples || []);
    
    console.log('üìä ARTIGOS SELECIONADOS PARA AN√ÅLISE:', artigosRelacionados.length);

    if (artigosRelacionados.length === 0) {
      console.log('‚ùå NENHUM DOCUMENTO RELACIONADO ENCONTRADO');
      
      return new Response(JSON.stringify({
        documentos_relacionados: [],
        recomendacao: "√ìtimo! Nenhum documento parecido encontrado. Este parece ser um conte√∫do novo.",
        analise_comparativa: null,
        deve_criar_novo: true
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log('üéØ ETAPA 5: RE-RANKING COM LLM');
    
    // Re-ranking com LLM se temos candidatos
    const documentosReRankeados = await rerankComLLM(artigosRelacionados, textoCompleto);
    
    console.log('üìä DOCUMENTOS AP√ìS RE-RANKING:', documentosReRankeados.length);
    documentosReRankeados.forEach((doc, i) => {
      console.log(`  ${i+1}. ${doc.titulo} (score: ${doc.score})`);
    });

    console.log('üéØ ETAPA 6: GERANDO AN√ÅLISE COMPARATIVA');
    
    const analiseComparativa = await gerarAnaliseComparativa(textoCompleto, documentosReRankeados);
    
    console.log('‚úÖ AN√ÅLISE COMPARATIVA GERADA');
    console.log('- Tamanho da an√°lise:', analiseComparativa?.length || 0, 'caracteres');

    console.log('üéØ ETAPA 7: PREPARANDO RESPOSTA FINAL');
    
    const resposta = {
      documentos_relacionados: documentosReRankeados.map(doc => ({
        id: doc.id,
        titulo: doc.titulo,
        conteudo: doc.conteudo,
        categoria: doc.categoria,
        versao: doc.versao || 1,
        similaridade: Math.round((doc.score || doc.similarity || 0) * 100),
        criado_em: doc.criado_em,
        status: doc.status,
        tags: doc.tags || [],
        profile: doc.profile
      })),
      recomendacao: "Aten√ß√£o! Encontramos documentos similares. Considere atualizar um existente.",
      analise_comparativa: analiseComparativa,
      deve_criar_novo: false
    };
    
    console.log('‚úÖ PROCESSO CONCLU√çDO COM SUCESSO');
    console.log('- Documentos relacionados:', resposta.documentos_relacionados.length);
    console.log('- Tem an√°lise comparativa:', !!resposta.analise_comparativa);

    return new Response(JSON.stringify(resposta), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('‚ùå Erro na verifica√ß√£o de assuntos relacionados:', error);
    return new Response(JSON.stringify({
      error: 'Falha na consulta √† base de conhecimento.',
      details: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});